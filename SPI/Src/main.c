/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <GPIO_lib.h>
#include <SPI_lib.h>


#define MAX_LENGTH 500

char RcvBuff[MAX_LENGTH];

volatile char ReadByte;

volatile uint8_t rcvStop = 0;

volatile uint8_t dataAvailable = 0;


/*
 * PA4		SPI_1_NSS
 * PA5 		SPI_1_SCK
 * PA6 		SPI_1_MISO
 * PA7		SPI_1_MOSI
 * SPI#1
 *
 * ALTERNATE FUNCTION: 5
 */

void SPI_1_GPIOInits(void){
	GPIO_Handle_t SPIPins;

	SPIPins.GPIO_Regdef = GPIOA;
	SPIPins.GPIO_config.Pin_Mode = GPIO_MODE_ALTERNATE;
	SPIPins.GPIO_config.Pin_alt_func = 5;
	SPIPins.GPIO_config.Pin_Output_Type = GPIO_PUSH_PULL;
	SPIPins.GPIO_config.Pin_Pull= GPIO_PULL_UP;
	SPIPins.GPIO_config.Pin_Speed = GPIO_SPEED_HIGH;

	//NSS
	SPIPins.GPIO_config.Pin_Number = GPIO_PIN_4;
	GPIO_Init(&SPIPins);

	//SCK
	SPIPins.GPIO_config.Pin_Number = GPIO_PIN_5;
	GPIO_Init(&SPIPins);

	//MISO
	SPIPins.GPIO_config.Pin_Number = GPIO_PIN_6;
	GPIO_Init(&SPIPins);

	//MOSI
	SPIPins.GPIO_config.Pin_Number = GPIO_PIN_7;
	GPIO_Init(&SPIPins);

	// CS PIN
	SPIPins.GPIO_Regdef = GPIOE;
	SPIPins.GPIO_config.Pin_Mode = GPIO_MODE_OUTPUT;
	SPIPins.GPIO_config.Pin_Output_Type = GPIO_PUSH_PULL;
	SPIPins.GPIO_config.Pin_Pull = GPIO_NO_PULL;
	SPIPins.GPIO_config.Pin_Speed = GPIO_SPEED_HIGH;
	SPIPins.GPIO_config.Pin_Number = GPIO_PIN_3;
	GPIO_Init(&SPIPins);

	GPIO_WritePin(GPIOE, GPIO_PIN_3, GPIO_PIN_SET);
}

SPI_Handle_t SPI_1_handle;

void SPI_1_Inits(void){


	SPI_1_handle.pSPIx = SPI1;
	SPI_1_handle.SPIConfig.SPI_BusConfig = SPI_BUS_CONFIG_FD;
	SPI_1_handle.SPIConfig.SPI_DeviceMode = SPI_DEVICE_MODE_MASTER;
	SPI_1_handle.SPIConfig.SPI_SclkSpeed = SPI_SCLK_SPEED_DIV64;
	SPI_1_handle.SPIConfig.SPI_DFF = SPI_DFF_8BITS;
	SPI_1_handle.SPIConfig.SPI_CPOL = SPI_CPOL_LOW;
	SPI_1_handle.SPIConfig.SPI_CPHA = SPI_CPHA_LOW;
	SPI_1_handle.SPIConfig.SPI_SSM = SPI_SSM_EN; // HARDWARE SSM
			//SPI_SSM_EN;    // SOFTWARE SSM

	SPI_Init(&SPI_1_handle);
}




void write_L3GD20(uint8_t address, uint8_t data){


			uint8_t command = address;
			uint8_t dummy_read;

			//TURN ON SPI
			SPI_Enable(SPI1,ENABLE);

			// SET CS PIN
			GPIO_WritePin(GPIOE, GPIO_PIN_3, GPIO_PIN_RESET);

			SPI_SendData(SPI1, &command, 1);
			//DUMMY BYTE TO CLEARE RXNE
			SPI_ReceiveData(SPI1, &dummy_read, 1);

			//DUMMY BYTE to READ BUFFER
			SPI_SendData(SPI1, &data, 1);
			SPI_ReceiveData(SPI1, &dummy_read, 1);

			//turn off CS PIN
			GPIO_WritePin(GPIOE, GPIO_PIN_3, GPIO_PIN_SET);

			//checks if SPI is busy and turn off SPI
			while(SPI_GetFlagStatus(SPI1, SPI_BUSY_FLAG));
			SPI_Enable(SPI1,DISABLE);

}

uint8_t read_L3GD20(uint8_t address){

		uint8_t read_buffer;
		uint8_t dummy_read;
		uint8_t dummy_byte=0xFF;

		//dodanie do command funkcji READ
		uint8_t command = address + 0x80;

		//TURN ON SPI
		SPI_Enable(SPI1,ENABLE);

		// SET CS PIN
		GPIO_WritePin(GPIOE, GPIO_PIN_3, GPIO_PIN_RESET);

		SPI_SendData(SPI1, &command, 1);
		//DUMMY BYTE TO CLEARE RXNE
		SPI_ReceiveData(SPI1, &dummy_read, 1);

		//DUMMY BYTE to READ BUFFER
		SPI_SendData(SPI1, &dummy_byte, 1);
		SPI_ReceiveData(SPI1, &read_buffer, 1);

		//turn off CS PIN
		GPIO_WritePin(GPIOE, GPIO_PIN_3, GPIO_PIN_SET);

		//checks if SPI is busy and turn off SPI
		while(SPI_GetFlagStatus(SPI1, SPI_BUSY_FLAG));
		SPI_Enable(SPI1,DISABLE);

		return read_buffer;
}
int main (void){

	//INIT
	SPI_1_GPIOInits();
	SPI_1_Inits();

	//SET THE SSI TO VCC
	SPI_SSIConfig(SPI1, ENABLE);   //SET ONLY IN SOFTWARE SSM

	//CONFIGURE SOE FOR HARDWARE SSM
	//SPI_SSOEConfig(SPI1, ENABLE);

	//SPI_IRQITConfig(IRQ_NO_SPI1, ENABLE);

////////////////////////////////////////////////////////ODCZYTYWANIE CZUJNIKA L3G20
//
	uint8_t zmienna_rec = 0;

	//enable the L3GD20 module
	write_L3GD20(0x20, 0x0F);

	//{0x00 - dummy, 0x8F = whoami, A6 = temp_reg}
	uint8_t zmienna[] = {0x00, 0x0F, 0x2D};

	zmienna_rec = read_L3GD20(zmienna[1]);

	printf("Odczytano: %d \n", zmienna_rec);



	//read data
	zmienna_rec = read_L3GD20(zmienna[2]);

	printf("Odczytano: %d \n", zmienna_rec);
///////////////////////////////////////////////////////////////////////////////
//
//	uint8_t buff [] = {0x8F, 0xFF};
//
//	//ENABLE SPI PERIPHERAL
//	SPI_Enable(SPI1, ENABLE);
//
//	while(SPI_SendData_IT(&SPI_1_handle, buff, 1) == SPI_BUSY_IN_TX);
//	while(SPI_ReceiveData_IT(&SPI_1_handle, buff, 1) == SPI_BUSY_IN_RX);
//
//	while(SPI_SendData_IT(&SPI_1_handle, &buff[1], 1) == SPI_BUSY_IN_TX);
//	systick(4000);
//	while(SPI_ReceiveData_IT(&SPI_1_handle, buff, 1) == SPI_BUSY_IN_RX);
//
//	while(SPI_GetFlagStatus(SPI1, SPI_BUSY_FLAG));
//	SPI_Enable(SPI1, DISABLE);
//
//	printf("odebrano: %d", buff[0]);
/////////////////////////////////////////////////////////////////////////////

	while(1){

	}
	return 0;
}

void SPI1_IRQHandler(void){
	SPI_IRQHandling(&SPI_1_handle);
}
