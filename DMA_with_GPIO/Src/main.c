/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <TIMER_lib.h>
#include <GPIO_lib.h>
#include <DMA_lib.h>

uint32_t buff[20];

void GPIOInits(void){
	GPIO_Handle_t GPIOPins;

	//PUSH_BUTTON
	GPIOPins.GPIO_Regdef = GPIOA;
	GPIOPins.GPIO_config.Pin_Mode = GPIO_MODE_ALTERNATE;
	GPIOPins.GPIO_config.Pin_Output_Type = GPIO_PUSH_PULL;
	GPIOPins.GPIO_config.Pin_Pull= GPIO_NO_PULL;
	GPIOPins.GPIO_config.Pin_Speed = GPIO_SPEED_HIGH;
	GPIOPins.GPIO_config.Pin_alt_func = AF_1;
	GPIOPins.GPIO_config.Pin_Number = GPIO_PIN_0;
	GPIO_Init(&GPIOPins);


	GPIOPins.GPIO_Regdef = GPIOE;
	GPIOPins.GPIO_config.Pin_Mode = GPIO_MODE_OUTPUT;
	GPIOPins.GPIO_config.Pin_Output_Type = GPIO_PUSH_PULL;
	GPIOPins.GPIO_config.Pin_Pull= GPIO_PULL_DOWN;
	GPIOPins.GPIO_config.Pin_Speed = GPIO_SPEED_HIGH;

	//STM32_LEDS
	GPIOPins.GPIO_config.Pin_Number = GPIO_PIN_8;
	GPIO_Init(&GPIOPins);
	GPIOPins.GPIO_config.Pin_Number = GPIO_PIN_9;
	GPIO_Init(&GPIOPins);
	GPIOPins.GPIO_config.Pin_Number = GPIO_PIN_10;
	GPIO_Init(&GPIOPins);
	GPIOPins.GPIO_config.Pin_Number = GPIO_PIN_11;
	GPIO_Init(&GPIOPins);
	GPIOPins.GPIO_config.Pin_Number = GPIO_PIN_12;
	GPIO_Init(&GPIOPins);
	GPIOPins.GPIO_config.Pin_Number = GPIO_PIN_13;
	GPIO_Init(&GPIOPins);
	GPIOPins.GPIO_config.Pin_Number = GPIO_PIN_14;
	GPIO_Init(&GPIOPins);
	GPIOPins.GPIO_config.Pin_Number = GPIO_PIN_15;
	GPIO_Init(&GPIOPins);

}

void DMAInit(uint32_t* buffor){
	DMA_Handle_t DMA_st;

	DMA_st.DMA_NUMBER = DMA_NUM_1;
	DMA_st.CHANNEL_NUMBER = DMA_CHANNEL_7;
	DMA_st.SOURCE_ADDRESS = (TIM_2_BASEADDR + 0x4C);
	DMA_st.DESTINATION_ADDRESS = (uint32_t)buffor;
	DMA_st.NUMBER_OF_DATA_TRANSFER = 18;
	DMA_st.PRIORITY = DMA_PRIORITY_HIGH;
	DMA_st.M2M_MODE = 0;
	DMA_st.MEM_SIZE = DMA_MEM_SIZE_32_BIT;
	DMA_st.PERI_SIZE = DMA_MEM_SIZE_32_BIT;
	DMA_st.MEMORY_INCREMENT_MODE = 1;
	DMA_st.PERIPH_INCREMENT_MODE = 0;
	DMA_st.CIRCULAR_MODE = 1;
	DMA_st.DATA_TRANSFER_DIRECTION = DMA_READ_FROM_PERIPH;

	DMA_Init(&DMA_st);

	//set the DMA interrupt
	DMA_interrupt_set(DMA_NUM_1, DMA_CHANNEL_7);


}

void timer_abnormal_clk(void){

	//TURN ON TIMER_2 CLOCK
	RCC->APB1ENR |= (1<<0);
	/*
	 * 1. Configure channel 2 to detect rising edges on the TI2 input by writing CC2S= ‘01 in the
	TIMx_CCMR1 register.
	2. Configure the input filter duration by writing the IC2F[3:0] bits in the TIMx_CCMR1
	register (if no filter is needed, keep IC2F=0000).
	Note: The capture prescaler is not used for triggering, so you don’t need to configure it.
	3. Select rising edge polarity by writing CC2P=0 and CC2NP=0 and CC2NP=0 in the
	TIMx_CCER register.
	4. Configure the timer in external clock mode 1 by writing SMS=111 in the TIMx_SMCR
	register.
	5. Select TI2 as the input source by writing TS=110 in the TIMx_SMCR register.
	6. Enable the counter by writing CEN=1 in the TIMx_CR1 register.
	When a rising edge occurs on TI2, the counter counts once and the TIF flag is set.
	The delay between the rising edge on TI2 and the actual clock of the counter is due to the
	resynchronization circuit on TI2 input.
	 */

	//1. CC2 channel is configured as input, IC2 is mapped on TI2
	TIMER2->TIMx_CCMR1 |= (1 << 8);
	//2. default - no filter

	//3. default CC1P and CC1NP = 0 0

	//4. External Clock Mode 1 - Rising edges of the selected trigger (TRGI) clock the counter
	TIMER2->TIMx_SMCR |= (7<<0);

	//interrupt at every click
	TIMER2->TIMx_ARR = 1;

	__Timer_update_reg(TIMER2);

	//5.TIM2_CH1 Filtered Timer Input 1 (TI1FP1)
	TIMER2->TIMx_SMCR |= (5 << 4);

	//CC2 irq enable
	TIMER2->TIMx_DIER |= (1<<1);

	//Turn on CC2 DMA REQUEST ENABLE
	TIMER2->TIMx_DIER |= (1<< 10);

	TIMER_interrupt_set(TIMER2);

	//emable counter
	TIMER2->TIMx_CR1 |= (1<<0);

	//CCx DMA requests sent when update event occurs
	TIMER2->TIMx_CR2 |= (1<<3);

	//DMA BRUST 18 transfers
	TIMER2->TIMx_DCR |= (0x11 << 8);

	//6. interrupt at every click
	TIMER2->TIMx_CNT = 1;
}

int main (void){

	//INIT
	PeriClockControl(GPIOE, CLOCK_ENABLE);
	PeriClockControl(GPIOA, CLOCK_ENABLE);
	DMAClockControl(DMA_NUM_1, CLOCK_ENABLE);

	GPIOInits();

	timer_abnormal_clk();

	DMAInit(buff);

	while(1){
	}
	return 0;
}

void DMA1_CH7_IRQHandler(){
	//CLEAR FLAGS
	DMA_RegDef_t* DMA_handler = (DMA_RegDef_t*)DMA_1_BASEADDR;
	DMA_IRQ_handling(DMA_handler);
}

void TIM2_IRQHandler (){
	static uint8_t pin_number = 8;

	Timer_IRQ_handling(TIMER2);

	GPIO_TogglePin(GPIOE, pin_number++);

	if(pin_number == 16)
			pin_number = 8;

	//tim interrupt every click;
	TIMER2->TIMx_CNT = 1;
}
